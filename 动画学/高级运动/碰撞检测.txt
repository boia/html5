	我们已经知道如何移动物体以及如何使物体与它们所占有的空间产生交互。现在将深入研究这些物体之间的交互，通常，这将涉及判断两个物体何时产生接触。该问题称为碰撞检测或碰撞测试。
	

1.碰撞检测方法

	有两种方法来进行碰撞检测:
	①你可以基于每一个对象的实际像素来测试，也就是说，一个精灵的图形是否覆盖了另一个的图形？对于这个测试，你是否考虑了精灵的实际可见像素？或者你基于的是否是精灵的方形边界？

	②你可以基于距离进行碰撞测试。首先得到两个物体之间的距离，然后你问:"他们是否已经足够接近以至于要发生碰撞?",你需要计算距离


2.hitTestObject和hitTestPoint
	
	hitTestObject方法用于测试一个显示对象是否碰撞到另外一个，hitTestPoint方法用来检测一个指定的点是否碰撞到一个显示对象。

2.1.碰撞测试两个精灵

	使用hitTestObject来检测两个精灵是否彼此碰撞可能是最简单的碰撞检测方法，也是最容易编程和执行最快的方法
	先在精灵的外围做一个矩形，把精灵包在里面，然后开始检测

	检测不相交和相交方法是对立的

	判断A和B俩矩形相交的算法是 A最大的x值是否>=B最小的x值&&A最大的y值>=B最小的y值&&B最大的x值是否>=A最小的x值&&B最大的y值是否>=A最小的y值
	好绕啊，咱换个思路理解，判断A和B俩矩形不相交的算法是 
	A最大的x值<B最小的x值||A最大的y值<B最小的y值||B最大的x值<A最小的x值||B最大的y值<A最小的y值
	然后利用求非公式换算下,<变>=  &&变||就行了

	hitTestPoint方法有很大的不同，他是判断精灵有没有碰撞到那个点

实例  https://github.com/boia/html5/blob/animation/动画学/高级运动/检测相交.html

	在flash中有一个shapeFlag标志，如果为true，那么实用边界盒(外围矩形)来测试，如果false，那么实用对象自身来测试，只有真正碰到对象，而不是边界盒才会触发碰撞。

2.2.hitTest总结

	对于两个不规则形状的精灵你要如何进行碰撞测试，以致如果其中的任何一部分碰到另外一个，你得到碰撞了吗？
	概括一下，基本选择如下:
	①对于粗糙的矩形影片剪辑，使用hitTestObject;
	②对于非常小的精灵，可以使用hitTestPoint;
	③对于形状非常不规则的精灵，要么忍受不准确，要么使用自定义的程序来解决


2.3.基于距离的碰撞检测

	使用两个物体的距离来确定两者是否发生碰撞
	很自然，这里有一个疑问，简单的hitTestObject方法对于矩形可以工作的很好，但对于不是矩形的其它形状就会出现问题，而当前这种方法偏爱完美的原型
	当使用的并不是圆形时，你将会看到一些不准确的情况，但并不是你之前使用hitTest和边界盒时出现的将没有碰撞的物体报告为碰撞的问题，恰恰相反，看上去已经接触的物体并没有碰撞，因为中心没有足够接近

2.3.1.简单的基于距离的碰撞检测

	两个正圆，可以再次使用Ball类，(这时候你就明白为什么在面向对象编程中经常会使用"可复用这个词")，当做这种类型的碰撞检测时，注册点应当位于圆的正中心
	使用两个圆心的距离来判断，这时候使用毕达哥拉斯定理，原理很简单

	公式:dx = ball2.x-ball1.x;
	     dy=ball2.y-ball1.y; 
	     dist=Math.sqrt(dx*dx+dy*dy);
	     if(dist < ball2.radius+ball1.radius){//碰撞代码}

2.3.2.基于碰撞的弹性

	当两个物体碰撞时如何反应和如何有效地处理多个物体之间的交互。
	这里有一个思路，将一个打球，放在舞台的中央，然后加入一系列的小球，有大小和速度，如果一个移动的小球弹到目标点，然后，你要让他在弹回来，在中心球外面设置一个目标点，一旦到达目标点，不在进行碰撞。
	有很多思路，不一定选这个

	
2.4.多物体碰撞检测策略
	当只有两个物体在屏幕上移动时，测试它们是非常容易的，但是当有几个物体或者几十个物体，需要一种策略来检测它们了

2.4.1.基本的多物体碰撞检测

	两个物体，只有一种可能 A对B ，3个物体:A-B、B-C和C-A,n个物体有n+n-1+n-2....+2+1个独立的组合,算法的处理越简单越好
	//num是小球的个数
	for(var i=0;i<num-1;i++){
		for(j=i+1;j<num;j++){
			if(balls[i].hitTestObject(balls[j])){
				//碰撞响应
			}
		}
	}
	我们看下这个优化的算法，传入比较的参数的对象的索引永远比待检测对象的索引大，而且不会有重复的比较，并且只要比到倒数第二个对象就行了

2.4.2.多物体弹性

	我们来做一个另外的应用程序，是气泡类型的，这一次，所有的气泡可以彼此回弹。
	

2.5.其他的碰撞检测方法
	hitTest方法和基于距离的碰撞检测并不是查出一个物体是否碰到另一个物体的仅有的方法，但是它们两者，可以帮你解决大部分问题
	Google里可以搜到一些牛的算法，www.gskinner.com
	
	
	